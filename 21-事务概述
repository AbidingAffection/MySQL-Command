
1、什么是事务
	事务就是一个完整的业务逻辑，那什么是一个完整的业务逻辑。
	假设从A账户向B账户转账10000，那么A账户减去10000，B账户加上10000，折就是一个完整的业务逻辑。
	以上的操作是一个最小工作单元，要么同时成功，要么同时失败，不可再分。

	只有insert、delete、update三个语句和事务有关系，其他都和事务没有关系。
	所以说到底，事务就是批量的DML语句，同时成功或者同时失败。


2、事务是如何做到的
	InnoDB存储引擎:提供了一组用来记录事务性活动的日志文件。
	事务开始了:
	insert
	insert
	insert
	delete
	update
	update
	事务结束了!
	
	在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。
	在事务的执行过程中，我们可以提交事务，也可以回滚事务。
	
	提交事务:清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。
		   提交事务标志着，事务的结束，并且是一种全部成功的结束。
	
	回滚事务:将之前所有DML操作全部撤销，并且清空事务性活动的日志文件。
		   回滚事务标志着，事务的结束，并且是一种全部成功的结束。
	

3、事务的特征
	事务可以保证多个操作原子性,要么全成功,要么全失败。
	对于数据库来说事务保证批量的 DML 要么全成功,要么全失败。

	事务具有四个特征 ACID
		a) 原子性(Atomicity) 说明事务是最小工作单元，不可再分。
		b) 一致性(Consistency) 在同一个事务中，所有操作必须同时成功或者同时失败，以保证数据的一致性。
		c) 隔离性(Isolation) 一个事务不会影响其他事务的运行。
		d) 持久性(Durability) 在事务完成以后,该事务对数据库所作的更改将持久地保存在数据库之中,并不会被回滚。

	事务中存在一些概念:
		a) 事务(Transaction):一批操作(一组 DML)
		b) 开启事务(Start Transaction)
		c) 回滚事务(rollback)
		d) 提交事务(commit)
		e) SET AUTOCOMMIT:禁用或启用事务的自动提交模式
		
	在MySQL中，对事务的处理机制是默认提交，所以我们每执行一次DML语句，数据都会被持久化。
	使用Start Transaction语句，这样MySQL默认的事务提交机制便关闭了，需要我们手动commit。
	

4、事务的隔离性
	隔离级别:A教室和B教室中间有一道墙，可以很厚也可以很薄。
		读未提交: read uncommitted (最低的隔离级别) 《没提交就能读到》
		读已提交: read committed					《提交后才能读到》
		可重复读: repeatable read	 （默认隔离级别）	《提交后也读不到，永远是事务开启时的数据》
		序列化: serializabale      (最高的隔离级别)	《提交前啥都不能做》
	
	读未提交:事务A可以读取到事务B未提交的数据。 (相当于教室A里面的人可以听见教室B里面的 每个人说的话)
	   问题:存在的问题是 脏读，称B还未提交的数据为脏数据。 这种隔离级别一般是理论上的，大多数数据库都是二档起步。
		
	读已提交:事务A只能读取到事务B已提交的数据。
	   解决:解决了脏读问题。
	   问题:存在的问题是 不可重复读取数据。比如在B事务开启后，A第一次读到的数据是3条，当前B事务还没结束，
	       A第二次读取的时候可能是4条记录，3!=4称为不可重复读。
	   
	可重复读:事务A开始后，不管多久，即使B已经修改了数据，A每次读取事务B中的数据都是一致的。
	   解决:解决了不可重复读取数据的问题。
	   问题:存在的问题是 幻影读。
	   案例:比如银行总账，需要从下午1点到下午3点。但是为了保证当前计算的银行总账，不受执行期间的存取款影响，就要使用这个隔离级别。
	   
	序列化:最高隔离级别，要求事务排队不能并发;解决了所有问题，但是效率低。
	  案例:比如银行总账，如果使用这个隔离级别，那么下午1点-->3点期间，大家都不能存款和取款了。






